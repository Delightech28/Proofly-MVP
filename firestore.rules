rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Users collection: allow users to create and manage their own profile,
    // but disallow client updates to protected counters and referral audit fields.
    match /users/{userId} {
  // Allow authenticated users to read/get user profiles. Previously this
  // restricted reads to owners or public profiles only; that prevented
  // client code from calling getDoc() on other users even though queries
  // (list) were allowed. Allowing authenticated reads lets follow/unfollow
  // handlers read the necessary counts. Tighten later if you need more
  // privacy controls.
  allow get, read: if request.auth != null;
      // Allow listing (queries) for authenticated users, but require client queries 
      // to include a filter for public profiles
      allow list: if request.auth != null;

  // Relaxed create rule for testing: allow any authenticated user to create their
  // own profile document as long as the document ID and the `uid` field match.
  // NOTE: This is relaxed for testing follow/unfollow behavior; revert to the
  // stricter checks before production.
  allow create: if request.auth != null
        && request.auth.uid == userId
        && request.resource.data.uid == userId;

      allow update: if request.auth != null && (
                    // owner may update their profile
                    request.auth.uid == userId
                    // allow authenticated clients to perform a single-field increment/decrement
                    || (
                      ('followersCount' in request.resource.data)
                      && request.resource.data.followersCount is int
                      && (
                        // normal increment/decrement when the field already exists
                        (('followersCount' in resource.data) && (request.resource.data.followersCount == resource.data.followersCount + 1 || request.resource.data.followersCount == resource.data.followersCount - 1))
                        // or allow creating the field from missing -> 1 (first follower)
                        || (!('followersCount' in resource.data) && request.resource.data.followersCount == 1)
                      )
                    )
                    || (
                      ('followingCount' in request.resource.data)
                      && request.resource.data.followingCount is int
                      && (
                        (('followingCount' in resource.data) && (request.resource.data.followingCount == resource.data.followingCount + 1 || request.resource.data.followingCount == resource.data.followingCount - 1))
                        || (!('followingCount' in resource.data) && request.resource.data.followingCount == 1)
                      )
                    )
                  );

      // Allow managing followers/following subcollections for follow/unfollow actions
      match /followers/{followerId} {
        // A user may create a follower record under another user's followers collection
        // only if they are the authenticated user and the doc contains their uid and doesn't already exist.
        allow create: if request.auth != null
                      && request.auth.uid == followerId
                      && request.resource.data.uid == followerId
                      && !exists(/databases/$(database)/documents/users/$(userId)/followers/$(followerId));

        // A follower may remove their own follower doc (unfollow)
        allow delete: if request.auth != null && request.auth.uid == followerId;

        // Allow owner to list/read their followers and follower to read their own follower doc
        allow read, list: if request.auth != null && (request.auth.uid == userId || request.auth.uid == followerId);

        // No updates allowed (create/delete only)
        allow update: if false;
      }

      match /following/{followingId} {
        // A user may create a following record under their own user doc when they follow someone
        allow create: if request.auth != null
                      && request.auth.uid == userId
                      && request.resource.data.uid == followingId
                      && !exists(/databases/$(database)/documents/users/$(userId)/following/$(followingId));

        // A user may remove (delete) their own following records
        allow delete: if request.auth != null && request.auth.uid == userId;

        // Users may read their own following list
        allow read, list: if request.auth != null && request.auth.uid == userId;

        allow update: if false;
      }

      allow delete: if false;
    }

    // Referral requests: clients may CREATE a request when signing up with a referral code.
    // Only the authenticated new user may create their own request; server (Cloud Function)
    // will process it and mark it processed.
    match /referralRequests/{reqId} {
      // Allow the signed-in user to create a referral request for themselves.
      allow create: if request.auth != null
                    && request.resource.data.newUid == request.auth.uid
                    && request.resource.data.code is string
                    && request.resource.data.code.size() > 0
                    && request.resource.data.code.size() <= 128
                    // prevent client from setting server-only fields
                    && !( 'processed' in request.resource.data )
                    && !( 'result' in request.resource.data )
                    && !( 'processedAt' in request.resource.data )
                    // optional: prevent clients from faking createdAt
                    && !( 'createdAt' in request.resource.data );

      // Allow the owner to read their specific request doc
      allow get: if request.auth != null && resource.data.newUid == request.auth.uid;

      // Disallow listing the whole collection from client
      allow list: if false;

      // Clients cannot update/delete requests; only server should
      allow update, delete: if false;
    }

    // referrals audit collection: only server / admin code should write audit records.
    match /referrals/{docId} {
      // Allow authenticated read for audit viewing if desired; tighten as needed
      allow read: if request.auth != null;
      allow create, update, delete: if false;
    }

    // referral summaries: allow users to read their own referral summary
    match /referralSummaries/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create, update, delete: if false; // Only server should manage these
    }

    // Chats collection (development-friendly rules)
    // Allows authenticated participants to create/read/update chat docs and to create/read messages.
    // NOTE: These rules are intentionally permissive for local/dev testing. Tighten before production.
    match /chats/{chatId} {
      // allow creation when the authenticated user is included in the participants array
      allow create: if request.auth != null
                    && ('participants' in request.resource.data)
                    && request.auth.uid in request.resource.data.participants;

      // allow read for participants. Also allow GET on a non-existent doc so
      // clients can check existence before creating a chat (helpful for startChat flow).
      allow get: if request.auth != null && (
        // if the document doesn't exist yet, allow GET so client can attempt to create it
        resource == null ||
        // otherwise only allow participants to read
        (resource.data.participants is list ? request.auth.uid in resource.data.participants : false)
      );

      // For dev/testing allow listing chats for authenticated users (keeps behaviour simple)
      allow list: if request.auth != null;

      // allow update for participants (typing, unreadCounts, lastMessage, etc.) during dev
      allow update: if request.auth != null
                    && (resource.data.participants is list
                      ? request.auth.uid in resource.data.participants
                      : false);

      // messages subcollection rules
      match /messages/{messageId} {
        // participants may create messages
        allow create: if request.auth != null
                      && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;

        // participants may read messages
        allow get, list: if request.auth != null
                         && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;

        // allow updates to message only by original sender (e.g., mark read/delivered)
        allow update: if request.auth != null && request.auth.uid == resource.data.senderId;

        allow delete: if false;
      }
    }

    // Default: deny everything else from client
    // Username mapping collection: small documents mapping username -> uid
    match /usernames/{username} {
      // Allow availability checks (reads) from client code
      allow get: if true;

      // Allow creating a mapping only if the client is authenticated,
      // the created document contains { uid: request.auth.uid },
      // and the document does not already exist (prevent overwrite).
      allow create: if request.auth != null
                    && request.resource.data.uid == request.auth.uid
                    && !exists(/databases/$(database)/documents/usernames/$(username));

      // Allow deleting a mapping only if the authenticated user owns it
      allow delete: if request.auth != null
                    && resource.data.uid == request.auth.uid;

      // Disallow arbitrary updates (changing owner must be done via create/delete)
      allow update: if false;
    }

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
